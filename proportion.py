# -*- coding: utf-8 -*-
"""proportion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lrJjP5hd1IBhN3RVaCA7luWBhGISeUb2
"""

drive.mount('/content/drive')

folder_path = "/content/drive/MyDrive/DSE4211/"

import os
print(os.listdir("/content/drive/MyDrive/DSE4211/"))

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

file_paths = {
    "Apple": "/content/drive/MyDrive/DSE4211/apple_price_data.csv",
    "BNB": "/content/drive/MyDrive/DSE4211/BNB_price_data.csv",
    "Bitcoin": "/content/drive/MyDrive/DSE4211/btc_price_data.csv",
    "JNJ": "/content/drive/MyDrive/DSE4211/JNJ_price_data.csv",
    "USDT": "/content/drive/MyDrive/DSE4211/USDT_price_data.csv",
    "Xiaomi": "/content/drive/MyDrive/DSE4211/Xiaomi_price_data.csv",
    "Gold_Tether": "/content/drive/MyDrive/DSE4211/Gold(Tether)_price_data.csv",
}

dfs = {}
for asset, path in file_paths.items():
    df = pd.read_csv(path)
    df.index = pd.date_range(start="2023-01-01", periods=len(df), freq="D")
    if "Close" in df.columns:
        df = df[["Close"]].rename(columns={"Close": asset})
    dfs[asset] = df

merged_df = pd.concat(dfs.values(), axis=1) # this merged_df merged close price for each asset

merged_df = merged_df.iloc[2:].apply(pd.to_numeric, errors='coerce')
merged_df.fillna(method='ffill', inplace=True)  # Forward-fill missing values

print("Cleaned Data (First 5 Rows):")
print(merged_df.head())

# Compute Daily Returns
returns = merged_df.pct_change().dropna()

# Features and Target for Random Forest
X = returns.shift(1).dropna()  # Features: Previous day returns
y = returns.loc[X.index]  # Target: Next day returns

# tran test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train Random Forest Model for Each Asset
rf_models = {}
predicted_returns = {}

for asset in returns.columns:
    rf = RandomForestRegressor(n_estimators=100, random_state=42)
    rf.fit(X_train_scaled, y_train[asset])  # Train model on asset's past returns
    rf_models[asset] = rf

    # Predict next day returns
    predicted_returns[asset] = rf.predict(X_test_scaled)[-1]  # Take the last prediction

# Convert predictions into a DataFrame
predicted_returns_df = pd.DataFrame(predicted_returns, index=["Predicted Return"])
print("\nPredicted Returns:")
print(predicted_returns_df)

# Convert Predictions into Portfolio Weights
predicted_returns_arr = np.array(list(predicted_returns.values()))
allocation_weights = predicted_returns_arr / np.sum(predicted_returns_arr)  # Normalize to sum to 1

# Display the optimal portfolio allocation
allocation_df = pd.DataFrame({"Asset": returns.columns, "Optimal Allocation (%)": allocation_weights * 100})
print("\nOptimal Portfolio Allocation:")
print(allocation_df)